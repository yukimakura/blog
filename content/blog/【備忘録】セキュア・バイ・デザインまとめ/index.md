---
title: 【備忘録】セキュア・バイ・デザインまとめ
date: "2024-06-22T09:00:00Z"
description: "セキュア・バイ・デザインを各章のまとめベースで自分なりに噛み砕く"
tags: ["読書","まとめ","備忘録"]
---
[<img src="https://m.media-amazon.com/images/I/61KPtQRcdKL._SL1286_.jpg" width="300px">](https://amzn.asia/d/0aduwAYU)
# 手法
各章にまとめがあるのでそれを箇条書き方式で詳細を枝生やしていく
※ゆきまくらが思ったことは項目末尾に `(感想)` と記載している

# 1章 なぜ、設計がセキュリティにおいて重要なのか？
- セキュリティを実装すべき機能 (feature) として見るのではなく、 対応しなければならない心配事 (concern) として見るようにする
- 開発中に、 セキュリティを最優先事項として常に考え続けるようなアプローチは現実的ではなく、より安全なソフトウェアを作成することに繋がる設計 (design) のアプローチを採用するほうが良い
- 能動的な意思決定が含まれるすべての行為はソフトウェアの設計の一部として捉えるべきであり、このような行為を設計と呼んでも過言ではない
- 設計とは、システムをどのように構築するのか、ということを導く原則であり、 コードからアーキテクチャまですべてのレベルにおいて適用できるものである
- 従来のソフトウェア・セキュリティのアプローチは、 開発者に対して、 セキュリティの脆弱性について常に考えることを求める一方、ビジネス機能を実装することも同時に求めていたため、 様々な問題が起きていた
    - さらに、 すべての開発者はセキュリティの専門家になることが求められ、 将来起こり得るすべての脆弱性について理解していることが求められていた
- 設計に意識を向けることで、 セキュリティについて常に考えていなくても、 良質なセキュリティ対策を実現できるようになる
- 設計を強く意識することで、 従来のソフトウェア・セキュリティのアプローチよりも安全な実装になる
- すべてのXMLパーサにはエンティティを使った攻撃に対する脆弱性が潜んでいる。これは
    - XMLのエンティティがXMLの言語仕様の一部だから
- 基本データ型やStringのような汎用的な型を使って特定のデータを表現することはセキュリティの脆弱性を生み出すことに繋がる
- XMLパーサをどのように設定するのかを判断することはそのXMLパーサの実装がどのようになっているのかを理解していないと簡単には行えない
- セキュア・バイ・デザイン (Secure by Design) はセキュリティ対策の層を積み重ねることで、多層セキュリティ (security in depth) を実現する

---
# 2章 ちょっと休憩：「ハムレット」の悲劇
- モデルが不完全であったり、何かが欠けていたり、 浅いモデリング (shallow modeling) がされたりした場合、 設計にセキュリティ上の欠陥が含まれる可能性が高くなる
- セキュリティの欠陥がビジネス的観点における完全性 (integrity) の破綻から生じている場合、その欠陥はプロダクトの中に昔から存在し、 経済的損失を出し続けている可能性がある
    - 意識的で明示的な設計を行うことで、より堅牢なソリューションを導き出せる

---
# 3章 ドメイン駆動設計の中核を成すコンセプト
- ドメインモデルを構築することで、より深くドメインについて理解できるようになる
    - ドメイン・モデルは曖昧さが排除された厳格な表現でなくてはならず、もっとも重要な部分のみを捉えるようにしなければならない
- ドメインモデルを作成する場合、様々な可能性のあるモデルの中からもっとも適したものを選ぶようにする
- ドメインモデルはシステムについて話し合う際の言語を形成する
- エンティティ、値オブジェクト (value object)、 集約 (aggregate) はドメインモデルを構築するための基本となる構成要素である
- エンティティはそのライフサイクルにおいて変わることのない識別性 (identity) を持つものであり、他のエンティティや値オブジェクトを含むこともできる
- エンティティの一意性には必ず範囲があり、その範囲はモデルによって異なる
- 値オブジェクトは識別性を持っておらず、その値によって区別されるものである
- 値オブジェクトはいかなるときも不変 (immutable) にし、完結した概念 (conceptual whole) を形成しなくてはならない
- 集約は他のモデル・オブジェクトを集めてグループ化した概念の境界を定義するものであり、そこに含まれるオブジェクトに課される不変条件 (invariant) を常に満たす責務を有する
- 集約は常にルート (root) を持っており、 コード上、 そのルートは集約と同じものになるのが一般的である
- 集約のルートはグローバルで一意となる識別性を持っており、 その理由は、ルートが他のモデルから参照できる集約の唯一の部分だからである
- ユビキタス言語はドメイン・エキスパートも含む開発に関わるすべての人が理解できるものであり、 同じ理解が共有されることを保証するためのものである
- ドメイン・モデルはユビキタス言語の意味が同じであるのかどうかで境界を分けられる
- 境界づけられたコンテキスト (bounded context) はそのモデルにおいて意味が通じるコンテキストのことである
    - もし、 異なる意味を持つものが現れたら、 そこにはコンテキストの境界があり、 そこで、モデルが分かれることになる
- コンテキストの境界を見つけるためには、 まずはConwayの法則について考えてみるのが良い
- もし、データが意味的境界 (semantic boundary) を超えてやり取りされるのであれば、そのデータはセキュリティの観点においても注意を払わなければならない
    - データが境界を超すことで、その概念の意味が気付かないうちに変わってしまうからである。

--- 
# 4章 安全性を確立する実装テクニック
- データの完全性 (integrity) とは、そのデータのライフサイクル全体において、状態が常に正しく正確であることを保証することである
- データの可用性 (availability) とは、データの取得やアクセスを想定しているパフォーマンスレベル内で行えることを保証することである
- オブジェクトを不変 (immutable) にすることで、そのオブジェクトが異なるスレッド間で共有されても、ロックをすることなく安全に扱えるようになる
    - その結果、 ロックがなくなるので、 ブロッキングも起こらなくなる
- データを不変にすることで、スケーラビリティが向上し、スレッド間のロックも行う必要がなくなるため、データの可用性が向上する
- 不変性を用いるとデータの変更が行えなくなるため、 データの完全性に関する問題がなくなる
- 契約 (contract) はオブジェクトやメソッドの責任を明確にするのに効果的な方法である
- 速やかな失敗 (fail-fast) をきちんと制御して発生させることのほうが、あとで制御不能な問題が起こるリスクを負うよりもましである。
    - 速やかに失敗させるためには、メソッドが処理を始める初期の段階で事前条件の確認を行わせる
- 妥当性確認 (validation) で行う確認の種類は、受け取るデータのオリジン (発生源)、 デ ータ・サイズ、字句的内容 (lexical content)、構文 (syntax)、意味 (semantic) に分けることができる
- オリジン (発生源)の確認は送信元のIPアドレスを確認することやアクセス・キーを要求することで行えるようになる。 
    - これを行うことで分散DoS (Distributed Denial of Service: DDoS) 攻撃の対策となる
- データサイズの確認はシステムの境界を超えるときとオブジェクトの生成時の両方で行うようにする
- 字句的内容 (lexical content) の確認はシンプルな正規表現を使って行えることがある
- 構文 (syntax) の確認はフォーマットを解析するパーサ (解析器) が必要である。 
    ただし、パーサの使用は他の確認よりもCPUやメモリーが消費されることを認識しておく必要がある
- 意味 (semantic) の確認では、データベース内のデータを見なくてはならないことがよくある
    - 例):指定したIDのレコードを検索する場合など
- 妥当性確認を行う順序は始めのほうはCPUやメモリーなどに掛ける負荷が低い確認を行うようにし、そのあとで負荷の高い確認を行うようにする
    - 早い段階で負荷の低い確認が失敗すれば、そのあとの負荷の高い確認を行わなくてもよくなるため

--- 
# 5章 ドメイン・プリミティブ
- ドメイン プリミティブ (domain primitive) はドメイン・モデルを構築する最小の要素であり、ドメイン・モデルの基礎を形成するものである
- ドメイン・モデルの概念を決して基本データ型や String などの汎用的な型で表現してはならない
- もし、ドメインで使われている用語が既にそのドメインの外にも存在していて、その意味が自身のドメインと少しでも異なるのであれば、 その用語の意味を再定義するのではなく、新しい用語を導入すべきである
- ドメイン プリミティブは不変 (immutable) であり、 対象のドメインにおいて有効となる場合にだけ存在できるものである
- ドメイン プリミティブを使うことで、その周りのコード(例えば、エンティティ)は非常にシンプルになり、より安全になる
- システム内で使われるAPIを堅牢なものにするためには、ドメイン プリミティブ・ライブラリを使うようにすべきである
- Read-Onceオブジェクト(一度しか読み込めないオブジェクト)は機密性の高いデータをコード上で表現するのに便利である
    - Read-Onceオブジェクトの値は一度しか取り出せない
    - Read-Onceオブジェクトによる設計パターンを用いることで機密性の高いデータが漏洩する可能性を減少できる
- ドメイン プリミティブを用いることで、 アプリケーションの実行中に行われる汚染解析(taint analysis)と同じ種類の安全性を得られるようになる

--- 
# 6章 状態の完全性の保証
- 可変(mutable)の状態を扱う場合、エンティティを利用するのが好ましい
- エンティティは作成された時点で正しい状態になっていなければならない
    - 引数なしのコンストラクタは危険である
- ビルダーパターンを使うことで、複雑な制約を持ったエンティティでも構築できるようになる
- エンティティのフィールドに対して何らかの操作が行われる場合、そのフィールドの完全性 (integrity) を保護しなければならない
- privateなデータ・フィールドに対して制限なしGetter/Setterメソッドがクラスにあることは、そのクラスにpublicなデータ・フィールドがあるのと同じくらい危険である
    - 可変オブジェクトを共有することは避け、不変 (immutable)オブジェクトであるドメインプリミティブを使うようにする
- エンティティが保持するコレクションに直接アクセスされないようにすべきであり、代わりに、エンティティからコレクションの操作を行える手段を提供すべきである
- エンティティのコレクションを提供する際に変更できないコレクションのビューを渡すことでエンティティのコレクションを保護する
- コレクションの要素が外部から変更されないように注意しなければならない

--- 
# 7章 状態の複雑さの軽減
- エンティティは部分的に不変(immutable)になるように設計できる
- 状態を別のオブジェクトとして切り出すことで、テスト時や開発時における状態の管理が簡単になる
- 高い能力を出すために複数のスレッドを用いるようにした環境では、注意深くエンティティを設計することが求められる
- データベースへのロックはエンティティの可用性(availability)を制限することになる
- エンティティ・スナップショットを導入することで、複数スレッドの環境において高い可用性を得られるようになる
- エンティティ・リレー (entity relay) は、 1つのフェーズを表すエンティティが終了すると、次のフェーズを表すエンティティが始まるようにしたパターン
    - 単一のエンティティの中で多くの状態が存在するようになってしまったものを別の方法でモデリングしたものである

--- 
# 8章 セキュリティを意識したデリバリ・パイプライン
- テストを正常値テスト、境界値テスト、異常値テスト、極端値テストに分けることで、単体テストの中にセキュリティを含められるようになる
- 正規表現は非効率なやり直しを行うようになっているため、データを正規表現エンジンに渡す前にそのデータの長さ(文字数)を確認しなくてはならない
- 機能トグル(feature toggle)はセキュリティの脆弱性の原因となることがあるが、 自動テストを用いてトグルの仕組みを検証することで、機能トグルの設定間違いによってセキュリティの問題が起こる可能性を軽減させられるようになる
- 私たち著者の経験から言えば、すべての機能トグルに対してテストを作成すべきであり、さらに、それらの組み合わせもすべてテストすべきである
- 機能トグルの数があまりにも多くなると組み合わせの複雑さが増すことに注意しなくてはならない
    - このような状況に陥ることを防ぐため、機能トグルの数はできるだけ少なくなるように努める
- セキュリティの観点において、機能トグルは監視され、その変更履歴を残すようにすべき対象である
- セキュリティの自動テストをビルド・パイプラインに組み込むことで、必要に応じてちょっとした侵入テスト(penetration test)を実施できるようになる
- セキュリティにおいて可用性 (availability) は重要であり、すべてのシステムにおいて考慮されなければならない
- DoS(Denial of Service)攻撃をシミュレーションすることで、 設計における脆弱な部分を全体的に把握しやすくなる
- ドメインDoS攻撃はそのサービスに対する一般的な利用との区別が難しいため、その攻撃を防ぐことは非常に難しい
- 設定の間違いによって引き起こされるセキュリティの問題はよくあることであり、その間違った設定の原因は設定に対する意図しない変更、意図した変更、誤解のどれかである
    - 設定のホットスポットを知ることで、設定に関してどこをテストするのかが分かりやすくなる
- 使用しているツールのデフォルトの振る舞いを知ることは重要であり、そのデフォルトの振る舞いをテストすることも重要である

--- 
# 9章 安全性を考えた処理失敗時の対策
- 技術的例外はドメインとは関係ないところで起こる例外であるため、ビジネス例外(business exception)と技術的例外(technical exception)を分けるような設計にする
- 技術的例外とビジネス例外を同じ型を使って表現すべきではない
- ビジネスデータは、それが機密性の高いものであるのかどうかに関わらず、技術的例外に決して含めない設計にする
- 失敗を想定した設計をしたり、失敗を通常の結果として扱う設計にしたりすることで、コードはより安全なものとなる
- 可用性(availability)を確保することはソフトウェア・システムのセキュリティにとって重要な目標である
- 回復性(resilience)と応答性(responsiveness)はシステムの可用性を向上させる要素であり、そのことが安全性の向上に繋がる
- サーキット・ブレイカーバルクヘッド、タイムアウトなどの設計パターンを用いることで高い可用性を持ったシステムを設計できる
- データを受け取る側が妥当性確認(validation)を行う前にそのデータを修正することは危険であり、何があっても避けなくてはならない
- 受け取ったデータをそのまま表示するようなことを決してしてはならない

--- 
# 10章 クラウド的考え方によるメリット
- Twelve-Factor Appとクラウド・ネイティブの2つのコンセプトはアプリケーションとシステムの安全性を向上させるのにも役立つ
- アプリケーションを状態を持たせない(stateless)プロセスとして設計し、好きなときに起動したり破棄したりできるようにしなくてはならない
- 処理の結果によって状態が変わる場合、その状態はデータベース、ログ・サービス、分散キャッシュなどのバックエンド・サービスに格納されるべきである
- コードと構成情報(configuration)を分離することで、アプリケーションをビルドしなおすことなく、そのアプリケーションを複数の環境にデプロイできるようになる
- 機密性の高いデータを決して構成ファイルに格納してはならない
    - アプリケーションが停止されたあともそのデータにアクセスできてしまうため
- 環境によって変わる構成情報はアプリケーションがデプロイされる環境に直接配置されるべきである
- システム管理者に課せられる作業は重要であるため、その作業を行うための機能をソリューションの一部として用意し、通常のビジネス機能を動かすプロセスとは別のプロセスとして運用すべきである
- ログをローカルサーバのディスク上にあるファイルに出力すべきではない
    - そのファイルから安全性を脅かす問題が生まれるから
- 一元管理されたログ・サービスを使うことで、セキュリティにおけるいくつかのメリットが得られるようになる
    - これはアプリケーションをクラウドで稼働していても、オンプレミスで稼働していても、同じである
- サービス検出 (service discovery) を導入することで、システムの可用性 (availability)が向上し、システムが常に変わり続けるようになることで、安全性が向上する
- エンタープライズ・セキュリティの3つの「R」というコンセプトを導入することで、セキュリティの様々な面を改善できるようになる
    - Rotate (定期的な変更)
    - Repave (作り直し)
    - Repair (修復) 
- クラウド向けのアプリケーションを設計する場合は、この3つの「R」を導入することが前提条件となる

--- 
# 11章 ちょっと休憩：保険料の支払いなしに成立してしまった保険契約
- 早い段階で意図的発見(deliberate discovery)を行うように努め、ドメインについて些細なことまで深く理解できるようにする
- モデリングを行う際は、詳細なモデルを作成することから始め、あとでそのモデルを抽象化することについて考える
- 自身のドメインと深い関係性を持つすべてのドメインからドメイン・エキスパートを集めるようにする
- 概念の意味が変わった場合、その概念の名前に対してリファクタリングを行うようにする。
    - 特に、他のコンテキストにある概念の意味も変えてしまうような場合はそのようにする


--- 
# 12章 レガシー・コードへの適用
- コンテキストの意味が変わる境界にはドメイン・プリミティブを導入すべきである 
    - コンストラクタやメソッドで使われている引数が曖昧な場合、セキュリティを脅かすバグの原因になりやすい
- コードを読む際に曖昧な引数について注意するようにし、そのような引数を見つけたら、直接的なアプローチ、検出によるアプローチ、新しいAPIを使ったアプローチを用いて対応すべきである
- 送られてきたデータを検査することなしに、そのままログに出力してはならない
    - 間接的インジェクション(second-order injection)攻撃のリスクがあるため
- 機密性の高い値にアクセスできる回数を制限する
    - 意図しないアクセスを検出できるようになる
- ログに出力したいフィールドのデータに対してアクセス・メソッドを明示的に呼び出すようにする
    - 新たにフィールドが追加されても、間違って出力されることがなくなる
- 過保護な実装は問題を起こしやすいため、契約やドメイン・プリミティブを用いて守るべきルールを明確にした実装にする
- DRY(Don't Repeat Yourself)原則は知識が繰り返し表現されることを意味しているのであり、テキストが繰り返されることを意味しているわけではない
- 知識の繰り返しではない繰り返されたテキストを減らそうとすることは不必要な依存関係を作り出す原因となる
- 記述されたテキストが異なるため知識の繰り返しを減らせなかった場合、妥当性確認(validation)に一貫性がなくなり、セキュリティを脅かす脆弱性となる可能性がある
- テストをすることでコードに潜む脆弱性を見つけられるようになる
    - 異常値テストや極端値テストも行うようにする
- ドメインプリミティブを定義する際は、完結した概念(conceptual whole)となるのに必要なすべての情報が含まれるようにする
- レガシーコードの改善では、適切な妥当性確認が行われていないドメイン固有の型を見つけ出すことに努め、そのような型をドメイン・プリミティブや安全なエンティティに置き換えるようにする

--- 
# 13章 マイクロサービスでの指針
- マイクロサービスに含まれる各サービスは独立して稼働できる実行環境を持ち、他のサービスに影響を与えることなく新しいバージョンに更新できなくてはならない
    - 他のサービスが動いていないときであっても、そのサービスは稼働できるように設計しなくてはならない
- マイクロサービスに含まれる各サービスを境界づけられたコンテキストとして扱うことで、より安全なAPIを設計できるようになる
- ドメイン プリミティブやコンテキストマップなどの安全な設計をするための原則はマイクロサービスのAPIを設計する場合にも適用できる
- よくあるセキュリティの落とし穴に陥るのを避けるため、APIにはドメインに関する操作のみを公開し、 異なるサービスとのやり取りにおいては明示的なコンテキスト・マップを使い、 APIを変更する際は特に注意を払わなければならない
- 機密性(confidentiality)、完全性(integrity)、 可用性(availability)、追跡可能性(traceability)を分析する際、すべてのサービスに渡って全体的に考えることが重要である
- 機密性が高く、複数のサービスにまたがって保護されなければないデータを識別できるようにする
- セキュリティの観点において、 ログデータの完全性は重要である
- ログデータの正規化と分類を行うには広範囲に渡るドメインの知識が必要であり、サービスの設計において考慮しなくてはならないものの1つである
- ログの出力元となるサービスは名前、バージョン、インスタンスIDによって一意に識別できるようにしなければならない
- トランザクションはシステムをまたいでも追跡できるようになっていなくてはならない。ドメインに基づくログAPIを用意することで、ログデータの機密性を考慮した設計が行いやすくなる
- 機密性の高いデータとそうではないデータを同じログに混ぜてはいけない。その理由は、機密性の高いデータが間違って流出する可能性があるからである

--- 
# 14章 最後に：セキュリティを忘れるべからず！
- セキュリティを意識したコード・レビューを安全なソフトウェアを開発するためのプロセスの中に組み込み、繰り返し行うようにする
- システムに対して様々な技術が積み重なっていくにつれ、それらの技術に含まれるセキュリティに関する脆弱性の情報を素早く得られる仕組みが必要となる
    - そのような仕組みに投資することが重要
- セキュリティの脆弱性を扱う戦略を通常の開発サイクルの一部として積極的に組み込むことで、より安全なソフトウェアを構築できるようになる
- 設計を検証し、ドメイン・モデルが変わることで生じる些細な問題を見つけ出すのに、 侵入テスト(penetration test)が有用である
- 侵入テストのフィードバックは起こしてしまった間違いについて学ぶ機会を得るためのものとして捉えるべきである
- バグ報奨金制度は常に終わることなく実施される侵入テストの代わりとして効果的な戦略ではあるが、バグ報奨金制度を実施することは難しく、実施するには膨大な投資と労力が必要になる
- 最新のセキュリティに関する情報を把握することは重要である
- 異なるドメインからの知識はセキュリティの問題を解決するのに有益である
- インシデント・ハンドリングと問題解決は意識する対象が異なる
- インシデント・ハンドリングにはチーム全体で取り組まなくてはならない
- セキュリティインシデントに対応する際、その攻撃に対してどうすればさらに堅牢になるのかを学習することに意識を向けるようにする

--- 


# 〆


では(^^)ノシ


