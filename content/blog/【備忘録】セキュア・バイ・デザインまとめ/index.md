---
title: 【備忘録】セキュア・バイ・デザインまとめ
date: "2024-06-22T09:00:00Z"
description: "セキュア・バイ・デザインを各章のまとめベースで自分なりに噛み砕く"
tags: ["読書","まとめ","備忘録"]
---
[<img src="https://m.media-amazon.com/images/I/61KPtQRcdKL._SL1286_.jpg" width="300px">](https://amzn.asia/d/0aduwAYU)
# 手法
各章にまとめがあるのでそれを箇条書き方式で詳細を枝生やしていく
※ゆきまくらが思ったことは項目末尾に `(感想)` と記載している

# 1章 なぜ、設計がセキュリティにおいて重要なのか？
- セキュリティを実装すべき機能 (feature) として見るのではなく、 対応しなければならない心配事 (concern) として見るようにする
    - セキュリティの機能と心配事は違う
        - 例): 銀行の金庫にて
            - 心配事: お金を盗まれないか
            - 機能：　扉に強力な錠前をつける
                - この例では、扉の蝶番が脆弱性として突かれ結局お金は盗まれてしまった...
        - 例): フォトサービス
            - 心配事: 写真を第三者に見られないか
            - 機能: ログイン画面を設けた！
                - この例では、URLを直接知られると第三者が写真を見れてしまう...
    - 如何に、ユーザーストーリから本質的な保護したい対象や手法を引き出すかが重要
        - **欲しいのはログイン画面なのではなく、情報を保護したい**
            - ログイン画面はあくまで情報を保護する手段の一つに過ぎない
- 開発中に、 セキュリティを最優先事項として常に考え続けるようなアプローチは現実的ではなく、より安全なソフトウェアを作成することに繋がる設計 (design) のアプローチを採用するほうが良い
- 能動的な意思決定が含まれるすべての行為はソフトウェアの設計の一部として捉えるべきであり、このような行為を設計と呼んでも過言ではない
    - 開発者が行っていることは、良い設計になるための実装とリファクタリングの繰り返し
    - そもそも、開発者によって「設計」とみなされる工程の認識がちがう
- 設計とは、システムをどのように構築するのか、ということを導く原則であり、 コードからアーキテクチャまですべてのレベルにおいて適用できるものである
- 従来のソフトウェア・セキュリティのアプローチは、 開発者に対して、 セキュリティの脆弱性について常に考えることを求める一方、ビジネス機能を実装することも同時に求めていたため、 様々な問題が起きていた
    - **すべての開発者はセキュリティの専門家になることが求められ、 将来起こり得るすべての脆弱性について理解していることが求められていた**
        - 攻撃経路、ゼロデイ攻撃、Web脆弱性、OWASP、そして今後出るであろう未知の攻撃などなど...
            - 全員がそれらの専門知識を持った開発など現実的ではない！
- 設計に意識を向けることで、 セキュリティについて常に考えていなくても、 良質なセキュリティ対策を実現できるようになる
    - 例): 各エンティティの仕様を厳格にし、インスタンス生成時に検証する
- 設計を強く意識することで、 従来のソフトウェア・セキュリティのアプローチよりも安全な実装になる
    - **セキュリティ対策をどのように(how)行うかを見る前になぜ(why)そのようなことをするのかについて理解することが重要**
    - 興味深い点として、厳格に仕様を決め、それを満たすように実装するだけで無意識的にセキュアになるケースすらある(感想)
    - エンジニアだけではなく、ドメインエキスパートやプロダクトオーナーも巻き込む形でセキュアなアプリケーションを作ることになる
        - 仕様を厳格にするとはそういうこと(感想)
        - **ビジネスの心配事とセキュリティにおける心配事の優先度が同等の扱いになれる！**
    - エンジニアとしても、**セキュリティの専門家でなくてもセキュアなコードが書ける**
- 追加でセキュリティに関する様々なアプローチを取り入れること
    - 侵入テスト(penetration test)
    - 特定の攻撃経路及び脆弱性について考えたテスト
- すべてのXMLパーサにはエンティティを使った攻撃に対する脆弱性が潜んでいる
    - XMLのエンティティがXMLの言語仕様の一部だから
        - XMLのエンティティの仕様そのものに脆弱性があるといっても過言ではない(感想)
- 基本データ型やStringのような汎用的な型を使って特定のデータを表現することはセキュリティの脆弱性を生み出すことに繋がる
    - エンティティや値オブジェクトをなるべく使うべし(感想、多分)
- XMLパーサをどのように設定するのかを判断することはそのXMLパーサの実装がどのようになっているのかを理解していないと簡単には行えない
- セキュア・バイ・デザイン (Secure by Design) はセキュリティ対策の層を積み重ねることで、多層セキュリティ (security in depth) を実現する

---
# 2章 ちょっと休憩：「ハムレット」の悲劇
- モデルが不完全であったり、何かが欠けていたり、 浅いモデリング (shallow modeling) がされたりした場合、 設計にセキュリティ上の欠陥が含まれる可能性が高くなる
    - その場しのぎのモデリングのことを浅いモデリングと本書では呼ぶ
        - 対象のドメインついて理解する機会を失うことになる
            - セキュリティに問題となる原因を抱え込む可能性も高くなる
        - 開発者側がドメインエキスパートに向けて詳細を掘り下げる質問(どういうこと？を数回繰り返す)を積極的にすることで、浅いモデリングを回避できるかも（感想）  
    - 深いモデリング
        - 深いモデリングを行うとより多くの重要な概念を見つけられる
        - 「この概念をどうようにコードで書くのか？」ではなく、「この概念をどうすれば理解できるのか」が重要
        - クラスの数が多くなるという指摘を受けるが、**概念を表現するクラスに記述されるコードはすべて必要なものである**
- セキュリティの欠陥がビジネス的観点における完全性 (integrity) の破綻から生じている場合、その欠陥はプロダクトの中に昔から存在し、 経済的損失を出し続けている可能性がある
    - 意識的で明示的な設計を行うことで、より堅牢なソリューションを導き出せる

---
# 3章 ドメイン駆動設計の中核を成すコンセプト
- ドメインモデルを構築することで、より深くドメインについて理解できるようになる
    - ドメイン・モデルは曖昧さが排除された厳格な表現でなくてはならず、もっとも重要な部分のみを捉えるようにしなければならない
    - **DDDはドメインが複雑なシステムの開発に活きる**
        - DDDが活きないシチュエーションもある(DDDは銀の弾丸ではない)
            - ネットワーク・ルーターの設計
                - 解決しなくてはならない問題はネットワークのパフォーマンス → **DDDが活きない！**
            - 空港の荷物預けシステム
                - 預けられた荷物が運搬されることをどのように表現されるかが重要 → **DDDが活きる！**
- ドメインモデルを作成する場合、様々な可能性のあるモデルの中からもっとも適したものを選ぶようにする
    - **モデルとは現実を簡素化したもの**
        - ドメインを表現するにおいて必要な情報のみを抽出する
            - 例)鉄道模型において大きさの比や色は必要だが、動力はどうでもいい
        - 単に現実を薄めたものでなく、**豊富な情報を失う代わりに厳格さを得たもの**
- ドメインモデルはシステムについて話し合う際の言語を形成する
    - 時には、作成する対象のシステムのドメインエキスパートも真のモデルを持っていないことがある
        - **その場合は、開発者とドメインエキスパートがともにモデルを作り上げるしかない**
- エンティティ、値オブジェクト (value object)、 集約 (aggregate) はドメインモデルを構築するための基本となる構成要素である
    - エンティティは維新が所有するオブジェクトの操作を調整する責務を有する
    - エンティティに値だけが保持され、そこで行うべき振る舞いを持たないと**ドメイン・モデル貧血症**を招く
- エンティティはそのライフサイクルにおいて変わることのない識別性 (identity) を持つものであり、他のエンティティや値オブジェクトを含むこともできる
- エンティティの一意性には必ず範囲があり、その範囲はモデルによって異なる
- 値オブジェクトは識別性を持っておらず、その値によって区別されるものである
    - **つまり、IDが無いのが正式な値オブジェクト**
- 値オブジェクトはいかなるときも不変 (immutable) にし、完結した概念 (conceptual whole) を形成しなくてはならない
    - ここでは、値オブジェクトはエンティティの参照はしても良いが、保持はNGと書いてあるが、シングルトンスコープのエンティティをインジェクションし、それの値をGetterで供給するのはOK？(疑問)
        - 概念的には参照に近いと思われる        
- 集約は他のモデル・オブジェクトを集めてグループ化した概念の境界を定義するものであり、そこに含まれるオブジェクトに課される不変条件 (invariant) を常に満たす責務を有する
- 集約は常にルート (root) を持っており、 コード上、 そのルートは集約と同じものになるのが一般的である
- 集約のルートはグローバルで一意となる識別性を持っており、 その理由は、ルートが他のモデルから参照できる集約の唯一の部分だからである
- ユビキタス言語はドメイン・エキスパートも含む開発に関わるすべての人が理解できるものであり、 同じ理解が共有されることを保証するためのものである
- ドメイン・モデルはユビキタス言語の意味が同じであるのかどうかで境界を分けられる
- 境界づけられたコンテキスト (bounded context) はそのモデルにおいて意味が通じるコンテキストのことである
    - ざっくりいうと、**定義したユビキタス言語が使える境界線のこと**
    - もし、 異なる意味を持つものが現れたら、 そこにはコンテキストの境界があり、 そこで、モデルが分かれることになる
        - 例)生産現場が必要と思うモデルと経理部門が必要と思うモデルは多少のギャップがある
            - **モデルの意味が共有できなくなったため、コンテキストの境界がある**
- コンテキストの境界を見つけるためには、 まずはConwayの法則について考えてみるのが良い
    - Conwayの法則とは、システムを設計する組織は、その構造をそっくりまねた構造の設計を生み出してしまうこと
    - 異なるコンテキスト間で同じ情報をやり取りしなければならないシチュエーションもある
        - 例)生産現場が必要とする注文情報と、経理部門が必要とする注文情報
            - しばしばDRY(Don't Repeat yourself)の乱用で問題を起こすことがある
- もし、データが意味的境界 (semantic boundary) を超えてやり取りされるのであれば、そのデータはセキュリティの観点においても注意を払わなければならない
    - データが境界を超すことで、その概念の意味が気付かないうちに変わってしまうからである。
    - コンテキストマップを用いると異なるコンテキスト同士がどのように境界を超えてやりとりするか表現できる
        - テキストで説明をつけた図や、単純にチーム間で話し合った結果の理解のこと

--- 
# 4章 安全性を確立する実装テクニック
- オブジェクトを不変 (immutable) にすることで、そのオブジェクトが異なるスレッド間で共有されても、ロックをすることなく安全に扱えるようになる
    - その結果、 ロックがなくなるので、 ブロッキングも起こらなくなる
- データの完全性 (integrity) とは、そのデータのライフサイクル全体において、状態が常に正しく正確であることを保証することである
- データの可用性 (availability) とは、データの取得やアクセスを想定しているパフォーマンスレベル内で行えることを保証することである
- データを不変にすることで、スケーラビリティが向上し、スレッド間のロックも行う必要がなくなるため、データの可用性が向上する
- 不変性を用いるとデータの変更が行えなくなるため、 データの完全性に関する問題がなくなる
- 契約 (contract) はオブジェクトやメソッドの責任を明確にするのに効果的な方法である
    - 契約はそれぞれのメソッドに対するのではなく、クラス全体に対する契約と考えるべき
- 速やかな失敗 (fail-fast) をきちんと制御して発生させることのほうが、あとで制御不能な問題が起こるリスクを負うよりもましである。
    - 速やかに失敗させるためには、メソッドが処理を始める初期の段階で事前条件の確認を行わせる
        - メソッドの頭で引数のデータや影響するクラス内変数をアサーションする
            - FluentAssertionとかつかうと良さげ(感想)
        - すくなくとも、すべてのPublicメソッドには実装するべき
            - Privateなものは頻度やケースによって実装しなくて良いものもある
- 妥当性確認 (validation) で行う確認の種類は、受け取るデータのオリジン (発生源,データ送信元)、 デ ータ・サイズ、字句的内容 (lexical content)、構文 (syntax)、意味 (semantic) に分けることができる
- オリジン (発生源,データ送信元)の確認は送信元のIPアドレスを確認することやアクセス・キー(OAuth)を要求することで行えるようになる。 
    - これを行うことで分散DoS (Distributed Denial of Service: DDoS) 攻撃の対策となる
        - 攻撃者が問題を起こすデータを送る労力よりも、開発者がシステムに対して悪意あるデータを対処する労力のほうが大きいため
- データサイズの確認はシステムの境界を超えるときとオブジェクトの生成時の両方で行うようにする
- 字句的内容 (lexical content) の確認はシンプルな正規表現を使って行えることがある
    - 受け取るデータに「<」や「>」が含まれてた場合はJSのコードが仕込まれてる可能性あり(XSS対策)
    - XMLの場合はEntity対策を忘れずに！
- 構文 (syntax) の確認はフォーマットを解析するパーサ (解析器) が必要である。 
    - ただし、パーサの使用は他の確認よりもCPUやメモリーが消費されることを認識しておく必要がある
    - もし、複雑な正規表現を書くことになるのなら、素直にロジックを書いたほうが良い
        - デバックのしやすさや可読性向上につながるはず（感想）
- 意味 (semantic) の確認では、データベース内のデータを見なくてはならないことがよくある
    - 例):指定したIDのレコードを検索する場合など
- 妥当性確認を行う順序は始めのほうはCPUやメモリーなどに掛ける負荷が低い確認を行うようにし、そのあとで負荷の高い確認を行うようにする
    - 早い段階で負荷の低い確認が失敗すれば、そのあとの負荷の高い確認を行わなくてもよくなるため

--- 
# 5章 ドメイン・プリミティブ
|実装テクニック|対応されるセキュリティの課題|
|--|--|
|ドメイン・プリミティブと不変条件|コードの不正確さ、エラーの起こりやすさ、曖昧さ|
|Read-Onceオブジェクト|機密性の高いデータの漏洩|
|ドメイン・プリミティブの応用|ロジックがあまりにも複雑になってしまったことによるコードの負担|

- ドメイン プリミティブ (domain primitive) はドメイン・モデルを構築する最小の要素であり、ドメイン・モデルの基礎を形成するものである
    - その存在だけで、その値が有効であることを保証する厳格な定義がなされた値オブジェクトのこと
        - DDDの値オブジェクトとの違いは、コンストラクタ時に値の不変条件が確認されること
            - 加えて、プログラミング言語標準のプリミティブな型やnullを許さない
- ドメイン・モデルの概念を決して基本データ型や String などの汎用的な型で表現してはならない
- もし、ドメインで使われている用語が既にそのドメインの外にも存在していて、その意味が自身のドメインと少しでも異なるのであれば、 その用語の意味を再定義するのではなく、新しい用語を導入すべきである
    - 世間一般で言われている概念の定義を変えてしまうことは混乱や誤解のもとで、それからバグにつながることがよくあるため
- ドメイン プリミティブは不変 (immutable) であり、 対象のドメインにおいて有効となる場合にだけ存在できるものである
    - 逆に、対象外のドメインにAPI経由でやり取りする場合は直接そのドメインプリミティブを渡してはならない
        - 対象のドメインの改善が後から非常にしにくくなるため
        - **DTOオブジェクトに変換した後にAPI渡しするべし！**
- ドメイン プリミティブを使うことで、その周りのコード(例えば、エンティティ)は非常にシンプルになり、より安全になる
    - エンティティの関数内で値の正当性の検証を行うことになり、エンティティにムダな責務が生じる→複雑になる
- システム内で使われるAPIを堅牢なものにするためには、ドメイン プリミティブ・ライブラリを使うようにすべきである
- Read-Onceオブジェクト(一度しか読み込めないオブジェクト)は機密性の高いデータをコード上で表現するのに便利である
    - Read-Onceオブジェクトの値は一度しか取り出せない
    - Read-Onceオブジェクトによる設計パターンを用いることで機密性の高いデータが漏洩する可能性を減少できる
    - **プログラミング言語やあるモデル（例：パスワード）などでは、できるだけメモリ内に重要な情報が残らないようにする実装の配慮も必要である**
- ドメイン プリミティブを用いることで、 アプリケーションの実行中に行われる汚染解析(taint analysis)と同じ種類の安全性を得られるようになる
    - 実際問題、ただのintやstringを全く制約なしに使えるケースは殆どないのである
        - 大抵の情報は何かしらの制約や上限・下限値がある

--- 
# 6章 状態の完全性の保証
- 可変(mutable)の状態を扱う場合、エンティティを利用するのが好ましい
    - 大半のシステムの中心となる関心事は、状態の変化に伴うシステムの振る舞いの変化
    - 様々なテクノロジーでこれは実現可能だが、**混ぜて使うと状態の一貫性がなくなるリスクがある**
        - どの状態になることが許可されて、どの状態に変わることができるのかを簡単に把握できるようにするべき
    - どのエンティティに状態を持たせるかを考えることも重要
        - 同じ状態でも、持たせるエンティティによって若干のニュアンスが変わることがある
- エンティティは作成された時点で正しい状態になっていなければならない
    - 引数なしのコンストラクタは危険である
        - 要するにドメインプリミティブにするべき(感想)
- フルーエント・インターフェイスパターン
    - 自己参照をチェーンで繋いで属性を付与することで、自然言語な記述でフィールドを設定できるようになる
        - 懸念点としてはコマンドクエリ原則を破ることになる
            - 返り値に自分を返す＆自分の中の変数をいじることになるから
    - 任意のフィールドに１つずつ値を設定する場合に効果を発揮する
    - 生成されるオブジェクトは値が追加されるたびに正しい状態であることを保証しなければならない
- ビルダーパターンを使うことで、複雑な制約を持ったエンティティでも構築できるようになる
    - コンストラクタをprivateにし、代わりにpublic staticなbuilderクラスをクラス内に用意すると良さげ
    - ビルダーパターンのプロパティ設定にフルーエントパターンを適応すると良い
    - ビルドメソッドの末端で、クラス内に保持していた製造物は破棄するべし
        - 再びビルドメソッドを呼ばれたときに同じ参照を渡さないための対策
            - 時と場合によっては、ビルド時にDeepCopyすればいいのでは？（疑問・感想）
- O/Rマッパーを使う場合は、マッピング後にオブジェクトの検証メソッドを呼ぶべき
    - もし、O/Rマッパーに自動で検証メソッドを呼ぶ機能があったら使うべし
    - ただし、コンストラクタで渡せれるO/Rマッパー及びコンストラクタで制約検証しているならその限りではない(はず)　(感想)
- エンティティのフィールドに対して何らかの操作が行われる場合、そのフィールドの完全性 (integrity) を保護しなければならない
- privateなデータ・フィールドに対して制限なしGetter/Setterメソッドがクラスにあることは、そのクラスにpublicなデータ・フィールドがあるのと同じくらい危険である
    - **カプセル化とは、データの解釈及びルールをそのデータと共に囲いこんで保護すること**であり、データ・フィールドが直接アクセスされないようにするためのものではない！
    - 可変オブジェクトを共有することは避け、不変 (immutable)オブジェクトであるドメインプリミティブを使うようにする
- エンティティが保持するコレクションに直接アクセスされないようにすべきであり、代わりに、エンティティからコレクションの操作を行える手段を提供すべきである
- エンティティのコレクションを提供する際に変更できないコレクションのビューを渡すことでエンティティのコレクションを保護する
- コレクションの要素が外部から変更されないように注意しなければならない

--- 
# 7章 状態の複雑さの軽減
- エンティティは部分的に不変(immutable)になるように設計できる
    - Javaでいうfinal,C#でいうinitアクセサー
- 状態を別のオブジェクトとして切り出すことで、テスト時や開発時における状態の管理が簡単になる
- 高い能力を出すために複数のスレッドを用いるようにした環境では、注意深くエンティティを設計することが求められる
    - ここの設計をミスるとスレッドのロックが発生しまくり、それがボトルネックになる
- データベースへのロックはエンティティの可用性(availability)を制限することになる
    - 可用性: システムが継続して稼働できる能力    
- エンティティ・スナップショットを導入することで、複数スレッドの環境において高い可用性を得られるようになる
    - 使えるリソースが限られている場合や、厳しい応答性をもとめられるケースでは導入の価値ありと思われる(と書籍に書いてある)
    - 可変なエンティティのとある一部のシーンを不変オブジェクトとして切り抜くパターン
        - デメリット
            - 単純に実装量が増える
            - オブジェクト指向の考え(データとそれに関する振る舞いをできるだけ一緒にする)から外れる
                - もっとも、これはコマンド・クエリ責務分離パターンや単一書き込み原則も同じことが言える
                    - 単一書き込み原則について(Copilotにより要約)
                        - この原則は、コードベースの一貫性と品質を保つために、特定のモジュールや機能に対して一人のモジュールが責任を持つべきだという考え方
                            - 一貫性の確保：一人のライターがコードを書くことで、スタイルや設計の一貫性が保たれる
                            - 責任の明確化：特定の部分に問題が発生した場合、誰が修正すべきかが明確になる
                            - 効率の向上：一人のライターが全体を把握しているため、修正や機能追加が迅速に行える
                            - 知識の集中：特定のモジュールに関する知識が一人に集中するため、その部分の専門家として機能する
                        - [ネタ元のMedium](https://richygreat.medium.com/single-writer-principle-9e2f78961390)
- エンティティ・リレー (entity relay) は、 1つのフェーズを表すエンティティが終了すると、次のフェーズを表すエンティティが始まるようにしたパターン
    - 単一のエンティティの中で多くの状態が存在するようになってしまったものを別の方法でモデリングしたものである
        - 沢山の状態を扱うようになってしまったエンティティをライフサイクルごとに分割し、それをリレー走のように繋いでいく考え方
            - こうすることで、エンティティ内で扱う状態が減り、脆弱性発生リスクを激減できる
    - エンティティで扱う状態が15個以上になったら積極的に導入を検討するべき
    - エンティティ・リレーが効果を発揮するのは以下の3つが揃ったとき
        - 1つのエンティティにあまりにも多くの状態がある場合
        - フェーズに分割する際、それらのフェーズが前のフェーズに決して戻ることがない場合
        - フェーズからフェーズへの遷移がシンプルで、遷移先のフェーズが非常に少ない場合

## この章で扱ったパターン
|パターン名|主要目的|対象とするセキュリティの種類|
|--|--|--|
|部分可変エンティティ|エンティティの中で変更すべきではない部分を不変にする|完全性|
|状態オブジェクト|エンティティを持つ状態で何が許可されているのかを把握しやすくする|完全性|
|エンティティ・スナップショット|ロックをしなくても良いようにすることで、十分なリソースの確保と素早いレスポンスを提供できるようにする|可用性、完全性|
|エンティティ・リレー|状態の数が多く複雑である場合、その遷移を簡単に扱えるようにする|完全性|

--- 
# 8章 セキュリティを意識したデリバリ・パイプライン
- 単体テストを正常値テスト、境界値テスト、異常値テスト、極端値テストに分けることで、セキュリティに関するチェックを含められるようになる

| テストの種類 | 目的 |
| -- | -- |
| 正常値テスト | ドメインルールを明らかに満たしているデータを受け取ったときの設計を検証する。つまり、実装したコードが **普通の正常値** を受け取ったときに正しく振る舞うことを確認する |
| 境界値テスト | 構造的に正しい値(受け取れる範囲の上限や下限など、頻度は非常に少ないが受信可能な有効データ)のみを受け付けることを検証する。境界値となるものにはデータの長さ、大きさ、数などが一般的だが、複雑な不変条件(invariant)やドメインルールによって意味が変わる境界(境界付けられたコンテキスト、具体例はP290参照)も含まれる |
| 異常値テスト | 有効でない値を受け取っても、 **設計が破綻しないこと** を検証する。異常値として考えられる値には、空のデータ構造体やnull、一般的には使われない文字(許可されない記号など)などがある |
| 極端値テスト | 極端な値を受け取っても、設計が破綻しないことを検証する。例えば、4000万字の文字列など |

- 正規表現は非効率なやり直しを行うようになっているため、データを正規表現エンジンに渡す前にそのデータの長さ(文字数)を確認しなくてはならない
- 機能トグル(feature toggle)はセキュリティの脆弱性の原因となることがあるが、 自動テストを用いてトグルの仕組みを検証することで、機能トグルの設定間違いによってセキュリティの問題が起こる可能性を軽減させられるようになる
    - 機能トグルの利点として、ソースコード管理においてメインブランチにて新機能を先行して実装できる
- 私たち著者の経験から言えば、すべての機能トグルに対してテストを作成すべきであり、さらに、それらの組み合わせもすべてテストすべきである
- 機能トグルの数があまりにも多くなると組み合わせの複雑さが増すことに注意しなくてはならない
    - このような状況に陥ることを防ぐため、機能トグルの数はできるだけ少なくなるように努める
- セキュリティの観点において、機能トグルは監視され、その変更履歴を残すようにすべき対象である
- セキュリティの自動テストをビルド・パイプラインに組み込むことで、必要に応じてちょっとした侵入テスト(penetration test)を実施できるようになる
- セキュリティにおいて可用性 (availability) は重要であり、すべてのシステムにおいて考慮されなければならない
- DoS(Denial of Service)攻撃をシミュレーションすることで、 設計における脆弱な部分を全体的に把握しやすくなる
- ドメインDoS攻撃はそのサービスに対する一般的な利用との区別が難しいため、その攻撃を防ぐことは非常に難しい
- 設定の間違いによって引き起こされるセキュリティの問題はよくあることであり、その間違った設定の原因は設定に対する意図しない変更、意図した変更、誤解のどれかである
    - 設定のホットスポットを知ることで、設定に関してどこをテストするのかが分かりやすくなる
- 使用しているツールのデフォルトの振る舞いを知ることは重要であり、そのデフォルトの振る舞いをテストすることも重要である

--- 
# 9章 安全性を考えた処理失敗時の対策
- 技術的例外はドメインとは関係ないところで起こる例外であるため、ビジネス例外(business exception)と技術的例外(technical exception)を分けるような設計にする
- 技術的例外とビジネス例外を同じ型を使って表現すべきではない
- ビジネスデータは、それが機密性の高いものであるのかどうかに関わらず、技術的例外に決して含めない設計にする
- 失敗を想定した設計をしたり、失敗を通常の結果として扱う設計にしたりすることで、コードはより安全なものとなる
- 可用性(availability)を確保することはソフトウェア・システムのセキュリティにとって重要な目標である
- 回復性(resilience)と応答性(responsiveness)はシステムの可用性を向上させる要素であり、そのことが安全性の向上に繋がる
- サーキット・ブレイカーバルクヘッド、タイムアウトなどの設計パターンを用いることで高い可用性を持ったシステムを設計できる
- データを受け取る側が妥当性確認(validation)を行う前にそのデータを修正することは危険であり、何があっても避けなくてはならない
- 受け取ったデータをそのまま表示するようなことを決してしてはならない

--- 
# 10章 クラウド的考え方によるメリット
- Twelve-Factor Appとクラウド・ネイティブの2つのコンセプトはアプリケーションとシステムの安全性を向上させるのにも役立つ
- アプリケーションを状態を持たせない(stateless)プロセスとして設計し、好きなときに起動したり破棄したりできるようにしなくてはならない
- 処理の結果によって状態が変わる場合、その状態はデータベース、ログ・サービス、分散キャッシュなどのバックエンド・サービスに格納されるべきである
- コードと構成情報(configuration)を分離することで、アプリケーションをビルドしなおすことなく、そのアプリケーションを複数の環境にデプロイできるようになる
- 機密性の高いデータを決して構成ファイルに格納してはならない
    - アプリケーションが停止されたあともそのデータにアクセスできてしまうため
- 環境によって変わる構成情報はアプリケーションがデプロイされる環境に直接配置されるべきである
- システム管理者に課せられる作業は重要であるため、その作業を行うための機能をソリューションの一部として用意し、通常のビジネス機能を動かすプロセスとは別のプロセスとして運用すべきである
- ログをローカルサーバのディスク上にあるファイルに出力すべきではない
    - そのファイルから安全性を脅かす問題が生まれるから
- 一元管理されたログ・サービスを使うことで、セキュリティにおけるいくつかのメリットが得られるようになる
    - これはアプリケーションをクラウドで稼働していても、オンプレミスで稼働していても、同じである
- サービス検出 (service discovery) を導入することで、システムの可用性 (availability)が向上し、システムが常に変わり続けるようになることで、安全性が向上する
- エンタープライズ・セキュリティの3つの「R」というコンセプトを導入することで、セキュリティの様々な面を改善できるようになる
    - Rotate (定期的な変更)
    - Repave (作り直し)
    - Repair (修復) 
- クラウド向けのアプリケーションを設計する場合は、この3つの「R」を導入することが前提条件となる

--- 
# 11章 ちょっと休憩：保険料の支払いなしに成立してしまった保険契約
- 早い段階で意図的発見(deliberate discovery)を行うように努め、ドメインについて些細なことまで深く理解できるようにする
- モデリングを行う際は、詳細なモデルを作成することから始め、あとでそのモデルを抽象化することについて考える
- 自身のドメインと深い関係性を持つすべてのドメインからドメイン・エキスパートを集めるようにする
- 概念の意味が変わった場合、その概念の名前に対してリファクタリングを行うようにする。
    - 特に、他のコンテキストにある概念の意味も変えてしまうような場合はそのようにする


--- 
# 12章 レガシー・コードへの適用
- コンテキストの意味が変わる境界にはドメイン・プリミティブを導入すべきである 
    - コンストラクタやメソッドで使われている引数が曖昧な場合、セキュリティを脅かすバグの原因になりやすい
- コードを読む際に曖昧な引数について注意するようにし、そのような引数を見つけたら、直接的なアプローチ、検出によるアプローチ、新しいAPIを使ったアプローチを用いて対応すべきである
- 送られてきたデータを検査することなしに、そのままログに出力してはならない
    - 間接的インジェクション(second-order injection)攻撃のリスクがあるため
- 機密性の高い値にアクセスできる回数を制限する
    - 意図しないアクセスを検出できるようになる
- ログに出力したいフィールドのデータに対してアクセス・メソッドを明示的に呼び出すようにする
    - 新たにフィールドが追加されても、間違って出力されることがなくなる
- 過保護な実装は問題を起こしやすいため、契約やドメイン・プリミティブを用いて守るべきルールを明確にした実装にする
- DRY(Don't Repeat Yourself)原則は知識が繰り返し表現されることを意味しているのであり、テキストが繰り返されることを意味しているわけではない
- 知識の繰り返しではない繰り返されたテキストを減らそうとすることは不必要な依存関係を作り出す原因となる
- 記述されたテキストが異なるため知識の繰り返しを減らせなかった場合、妥当性確認(validation)に一貫性がなくなり、セキュリティを脅かす脆弱性となる可能性がある
- テストをすることでコードに潜む脆弱性を見つけられるようになる
    - 異常値テストや極端値テストも行うようにする
- ドメインプリミティブを定義する際は、完結した概念(conceptual whole)となるのに必要なすべての情報が含まれるようにする
- レガシーコードの改善では、適切な妥当性確認が行われていないドメイン固有の型を見つけ出すことに努め、そのような型をドメイン・プリミティブや安全なエンティティに置き換えるようにする

--- 
# 13章 マイクロサービスでの指針
- マイクロサービスに含まれる各サービスは独立して稼働できる実行環境を持ち、他のサービスに影響を与えることなく新しいバージョンに更新できなくてはならない
    - 他のサービスが動いていないときであっても、そのサービスは稼働できるように設計しなくてはならない
- マイクロサービスに含まれる各サービスを境界づけられたコンテキストとして扱うことで、より安全なAPIを設計できるようになる
- ドメイン プリミティブやコンテキストマップなどの安全な設計をするための原則はマイクロサービスのAPIを設計する場合にも適用できる
- よくあるセキュリティの落とし穴に陥るのを避けるため、APIにはドメインに関する操作のみを公開し、 異なるサービスとのやり取りにおいては明示的なコンテキスト・マップを使い、 APIを変更する際は特に注意を払わなければならない
- 機密性(confidentiality)、完全性(integrity)、 可用性(availability)、追跡可能性(traceability)を分析する際、すべてのサービスに渡って全体的に考えることが重要である
- 機密性が高く、複数のサービスにまたがって保護されなければないデータを識別できるようにする
- セキュリティの観点において、 ログデータの完全性は重要である
- ログデータの正規化と分類を行うには広範囲に渡るドメインの知識が必要であり、サービスの設計において考慮しなくてはならないものの1つである
- ログの出力元となるサービスは名前、バージョン、インスタンスIDによって一意に識別できるようにしなければならない
- トランザクションはシステムをまたいでも追跡できるようになっていなくてはならない。ドメインに基づくログAPIを用意することで、ログデータの機密性を考慮した設計が行いやすくなる
- 機密性の高いデータとそうではないデータを同じログに混ぜてはいけない。その理由は、機密性の高いデータが間違って流出する可能性があるからである

--- 
# 14章 最後に：セキュリティを忘れるべからず！
- セキュリティを意識したコード・レビューを安全なソフトウェアを開発するためのプロセスの中に組み込み、繰り返し行うようにする
- システムに対して様々な技術が積み重なっていくにつれ、それらの技術に含まれるセキュリティに関する脆弱性の情報を素早く得られる仕組みが必要となる
    - そのような仕組みに投資することが重要
- セキュリティの脆弱性を扱う戦略を通常の開発サイクルの一部として積極的に組み込むことで、より安全なソフトウェアを構築できるようになる
- 設計を検証し、ドメイン・モデルが変わることで生じる些細な問題を見つけ出すのに、 侵入テスト(penetration test)が有用である
- 侵入テストのフィードバックは起こしてしまった間違いについて学ぶ機会を得るためのものとして捉えるべきである
- バグ報奨金制度は常に終わることなく実施される侵入テストの代わりとして効果的な戦略ではあるが、バグ報奨金制度を実施することは難しく、実施するには膨大な投資と労力が必要になる
- 最新のセキュリティに関する情報を把握することは重要である
- 異なるドメインからの知識はセキュリティの問題を解決するのに有益である
- インシデント・ハンドリングと問題解決は意識する対象が異なる
- インシデント・ハンドリングにはチーム全体で取り組まなくてはならない
- セキュリティインシデントに対応する際、その攻撃に対してどうすればさらに堅牢になるのかを学習することに意識を向けるようにする

--- 


# 〆


では(^^)ノシ


